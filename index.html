<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Jerry Parsnip's Gravel Graveyard ‚Äî Single File</title>
  <meta name="theme-color" content="#111111">
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      height: 100%;
      background: #0e0e0f;
      color: #eee;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    #hud {
      position: fixed;
      top: 0; left: 0; right: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: linear-gradient(180deg, rgba(0,0,0,0.7), rgba(0,0,0,0));
      z-index: 2;
      pointer-events: none;
    }
    #stats { display: flex; gap: 12px; font-weight: 600; }
    #title { font-weight: 700; letter-spacing: 0.3px; }
    #game {
      display: block;
      margin: 0 auto;
      max-width: 100vw;
      max-height: 100vh;
      background: #2a2a2e;
      border-left: 6px solid #222;
      border-right: 6px solid #222;
      touch-action: manipulation; /* better mobile taps */
    }
    #controls {
      position: fixed;
      bottom: 10px; left: 0; right: 0;
      display: flex; justify-content: center; gap: 16px;
      z-index: 2;
    }
    #controls button {
      width: 96px; height: 96px; border-radius: 50%;
      border: 0; font-size: 28px; font-weight: 700;
      background: #1d1e22; color: #fafafa;
      box-shadow: 0 4px 14px rgba(0,0,0,0.45);
    }
    #controls button:active { transform: scale(0.98); }
    .hidden { display: none !important; }
    #overlay {
      position: fixed; inset: 0;
      display: grid; place-items: center;
      background: rgba(0,0,0,0.7);
      z-index: 3;
    }
    .panel {
      background: #141416;
      border: 1px solid #2c2c32;
      border-radius: 12px;
      padding: 20px;
      width: min(92vw, 520px);
      text-align: center;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }
    .panel button {
      display: inline-block;
      padding: 12px 18px;
      font-size: 16px;
      border-radius: 10px;
      border: 0;
      background: #2a71ff;
      color: #fff;
      font-weight: 700;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div id="title">üö¥‚Äç‚ôÄÔ∏è Jerry Parsnip's Gravel Graveyard</div>
    <div id="stats">
      <span id="lives">Lives: 3</span>
      <span id="time">Time: 0s</span>
      <span id="lanes">Lanes: 3</span>
    </div>
  </div>

  <canvas id="game" width="480" height="800"></canvas>

  <div id="controls">
    <button id="leftBtn" aria-label="Move Left">‚óÄÔ∏é</button>
    <button id="rightBtn" aria-label="Move Right">‚ñ∂Ô∏é</button>
  </div>

  <!-- Visible on load; hidden on Start -->
  <div id="overlay">
    <div class="panel">
      <h1>Jerry Parsnip's Gravel Graveyard</h1>
      <p>Tap left/right (or use ‚óÄÔ∏é ‚ñ∂Ô∏é keys) to dodge the gravel. Three hits and Jerry goes OTB‚Ä¶ then ü™¶.</p>
      <button id="startBtn">Start Ride</button>
    </div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const hudLives = document.getElementById('lives');
    const hudTime = document.getElementById('time');
    const hudLanes = document.getElementById('lanes');

    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startBtn');

    // --- Game state ---
    const state = {
      running: false,
      lanes: 3,
      laneWidth: 0,
      playerLane: 1,
      lives: 3,
      t0: 0,
      elapsed: 0,
      speed: 220,
      wobbleT: 0,
      wobbleAmp: 0,
      gameOver: false,
      obstacles: [],
      spawnTimer: 0,
      spawnInterval: 650,
      gravestoneT: 0
    };

    // --- Sizing ---
    function resize() {
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      const w = Math.min(window.innerWidth, 600);
      const h = Math.min(window.innerHeight - 20, 1000);
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      computeLaneWidth();
    }
    function computeLaneWidth() {
      const roadMargin = 40;
      const roadWidth = canvas.width / (window.devicePixelRatio || 1) - roadMargin * 2;
      state.laneWidth = roadWidth / state.lanes;
    }

    // --- Controls ---
    function moveLeft() {
      if (!state.running || state.gameOver) return;
      state.playerLane = Math.max(0, state.playerLane - 1);
    }
    function moveRight() {
      if (!state.running || state.gameOver) return;
      state.playerLane = Math.min(state.lanes - 1, state.playerLane + 1);
    }

    leftBtn.addEventListener('click', moveLeft);
    rightBtn.addEventListener('click', moveRight);
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a') moveLeft();
      if (e.key === 'ArrowRight' || e.key === 'd') moveRight();
      if ((e.key === ' ' || e.key === 'Enter') && !state.running) { startGame(); }
    });
    // Tap anywhere on canvas to start if overlay is up
    canvas.addEventListener('touchstart', (e) => {
      if (!state.running) {
        startGame();
        return;
      }
      const x = e.touches[0].clientX;
      const mid = window.innerWidth / 2;
      if (x < mid) moveLeft(); else moveRight();
    });

    startBtn.addEventListener('click', startGame);
    window.addEventListener('resize', resize);
    resize();

    // --- Start / Reset ---
    function startGame() {
      reset();
      overlay.classList.add('hidden'); // ‚úÖ hide start panel immediately
    }

    function reset() {
      state.running = true;
      state.lanes = 3;
      state.playerLane = 1;
      state.lives = 3;
      state.t0 = performance.now();
      state.elapsed = 0;
      state.speed = 240;
      state.wobbleT = 0;
      state.wobbleAmp = 0;
      state.gameOver = false;
      state.obstacles.length = 0;
      state.spawnTimer = 0;
      state.spawnInterval = 650;
      state.gravestoneT = 0;
      computeLaneWidth();
      // ensure it is hidden even if called directly
      overlay.classList.add('hidden');
    }

    // --- Spawning (‚â§ two-thirds lanes blocked) ---
    function spawnRow() {
      const L = state.lanes;
      const maxGravel = Math.max(1, Math.floor(2 * L / 3));
      const gravelCount = Math.floor(Math.random() * maxGravel) + 1; // 1..maxGravel
      const lanes = new Set();
      while (lanes.size < gravelCount) {
        lanes.add(Math.floor(Math.random() * L));
      }
      if (lanes.size >= L) {
        const arr = Array.from(lanes);
        lanes.delete(arr[Math.floor(Math.random() * arr.length)]);
      }
      state.obstacles.push({ y: -40, lanes });
    }

    // --- Update ---
    function update(dt) {
      if (!state.running) return;

      state.elapsed = (performance.now() - state.t0) / 1000;

      // Lanes: 3 ‚Üí 5 at 60s ‚Üí 6 at 120s
      if (state.elapsed >= 120) {
        if (state.lanes !== 6) { state.lanes = 6; computeLaneWidth(); }
      } else if (state.elapsed >= 60) {
        if (state.lanes !== 5) { state.lanes = 5; computeLaneWidth(); }
      } else {
        if (state.lanes !== 3) { state.lanes = 3; computeLaneWidth(); }
      }

      // Speed ramps up gently
      state.speed = 240 + state.elapsed * 5;

      // Spawn timing tightens a bit over time
      state.spawnTimer += dt * 1000;
      const dynamicInterval = Math.max(320, state.spawnInterval - state.elapsed * 3);
      if (state.spawnTimer >= dynamicInterval) {
        state.spawnTimer = 0;
        spawnRow();
      }

      // Move rows
      for (const row of state.obstacles) { row.y += state.speed * dt; }
      state.obstacles = state.obstacles.filter(r => r.y < canvas.height + 80);

      // Collision check at rider Y
      const playerY = canvas.height - 120;
      const hitRows = state.obstacles.filter(r => r.y > playerY - 20 && r.y < playerY + 20);
      for (const r of hitRows) {
        if (r.lanes.has(state.playerLane) && !r.hit) {
          r.hit = true;
          state.wobbleT = 0.4;
          state.wobbleAmp = 10;
          state.lives -= 1;
          if (state.lives <= 0) {
            state.gameOver = true;
            state.gravestoneT = 1.5; // short OTB animation before grave
          }
        }
      }

      // wobble decay
      if (state.wobbleT > 0) {
        state.wobbleT -= dt;
        if (state.wobbleT <= 0) state.wobbleAmp = 0;
      }

      // HUD
      hudLives.textContent = 'Lives: ' + state.lives;
      hudTime.textContent = 'Time: ' + Math.floor(state.elapsed) + 's';
      hudLanes.textContent = 'Lanes: ' + state.lanes;
    }

    // --- Drawing ---
    function drawRoad() {
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);

      const roadMargin = 40;
      const roadLeft = w/2 - (state.laneWidth*state.lanes)/2;
      const roadRight = roadLeft + state.laneWidth*state.lanes;

      // asphalt
      const g = ctx.createLinearGradient(0,0,0,h);
      g.addColorStop(0, '#2b2b30');
      g.addColorStop(1, '#1f1f24');
      ctx.fillStyle = g;
      ctx.fillRect(roadLeft, 0, state.laneWidth*state.lanes, h);

      // lane markers
      ctx.strokeStyle = '#3b3b42';
      ctx.lineWidth = 2;
      for (let i = 1; i < state.lanes; i++) {
        const x = roadLeft + i*state.laneWidth;
        ctx.setLineDash([18, 14]);
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
        ctx.setLineDash([]);
      }

      // shoulder lines
      ctx.strokeStyle = '#cfcfd6';
      ctx.lineWidth = 4;
      ctx.setLineDash([24, 16]);
      ctx.beginPath(); ctx.moveTo(roadLeft, 0); ctx.lineTo(roadLeft, h); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(roadRight, 0); ctx.lineTo(roadRight, h); ctx.stroke();
      ctx.setLineDash([]);

      // gravel patches
      for (const row of state.obstacles) {
        for (let l = 0; l < state.lanes; l++) {
          if (row.lanes.has(l)) {
            const cx = laneCenter(l);
            const y = row.y;
            const wPatch = state.laneWidth * 0.8;
            const hPatch = 26;
            ctx.save();
            ctx.translate(cx, y);
            ctx.fillStyle = '#7a6d57';
            roundedRect(-wPatch/2, -hPatch/2, wPatch, hPatch, 8);
            ctx.fill();
            // speckles
            for (let i=0;i<18;i++){
              ctx.fillStyle = i%2? '#6a5f4d' : '#8a7b63';
              const rx = (Math.random()-0.5)*wPatch*0.8;
              const ry = (Math.random()-0.5)*hPatch*0.6;
              ctx.fillRect(rx, ry, 2, 2);
            }
            ctx.restore();
          }
        }
      }
    }

    function laneCenter(l) {
      const roadMargin = 40;
      const roadLeft = (canvas.width / (window.devicePixelRatio || 1)) / 2 - (state.laneWidth * state.lanes)/2;
      return roadLeft + l * state.laneWidth + state.laneWidth/2;
    }

    function roundedRect(x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
    }

    function drawPlayer() {
      const y = canvas.height - 120;
      const cx = laneCenter(state.playerLane);

      ctx.save();
      // wobble when hit
      const wobbleX = state.wobbleAmp * Math.sin((performance.now()/100) * 2 * Math.PI);
      ctx.translate(cx + wobbleX, y);

      if (state.gameOver) {
        if (state.gravestoneT > 0) {
          // quick OTB spin
          const t = state.gravestoneT;
          const a = (1.5 - t) * Math.PI;
          ctx.rotate(a);
          drawBike(0, 0, true);
        } else {
          drawGravestone();
        }
      } else {
        drawBike(0, 0, false);
      }

      ctx.restore();
    }

    function drawBike(x, y, crashed) {
      ctx.save();
      ctx.translate(x, y);
      // frame
      ctx.strokeStyle = crashed ? '#aa3333' : '#4cc9f0';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(-20, 10); ctx.lineTo(0, -18); ctx.lineTo(22, 8); ctx.lineTo(-10, 8); ctx.closePath();
      ctx.stroke();
      // wheels
      ctx.fillStyle = '#101014'; ctx.beginPath(); ctx.arc(-28, 18, 12, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(28, 18, 12, 0, Math.PI*2); ctx.fill();
      // rider
      ctx.fillStyle = '#f1d1b5'; // head
      ctx.beginPath(); ctx.arc(0, -30, 8, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#ff69b4'; // jersey
      ctx.fillRect(-10, -26, 20, 18);
      ctx.fillStyle = '#111'; // shorts
      ctx.fillRect(-8, -8, 16, 14);
      // bars
      ctx.strokeStyle = '#aaa'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(14, -6); ctx.lineTo(26, -6); ctx.stroke();
      ctx.restore();
    }

    function drawGravestone() {
      ctx.save();
      ctx.fillStyle = '#9ea3a8';
      roundedRect(-26, -40, 52, 60, 16);
      ctx.fill();
      ctx.fillStyle = '#5a5f66';
      ctx.fillRect(-30, 20, 60, 6);
      ctx.fillStyle = '#2c2f33';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('JERRY', 0, -10);
      ctx.fillText('ü™¶', 0, 6);
      ctx.restore();
    }

    function drawUI() {
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);
      // top progress bar (to 180s)
      const pct = Math.min(1, state.elapsed / 180);
      ctx.fillStyle = '#2a71ff';
      ctx.fillRect(0, 0, w*pct, 4);

      if (state.gameOver && state.gravestoneT <= 0) {
        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, w, h);
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.font = 'bold 28px system-ui, sans-serif';
        ctx.fillText('Over the Bars!', w/2, h/2 - 30);
        ctx.font = '16px system-ui, sans-serif';
        ctx.fillText(`Survived ${Math.floor(state.elapsed)}s  ‚Ä¢  Max lanes ${state.lanes}`, w/2, h/2 + 4);
        ctx.fillText('Tap Start to try again', w/2, h/2 + 32);
        ctx.restore();

        // show HTML overlay to restart on tap of Start
        overlay.classList.remove('hidden');
        startBtn.textContent = 'Restart Ride';
      }
    }

    // --- Main loop ---
    let last = performance.now();
    function frame(now) {
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;

      if (state.running && !state.gameOver) update(dt);
      if (state.gameOver && state.gravestoneT > 0) {
        state.gravestoneT -= dt;
        if (state.gravestoneT <= 0) state.gravestoneT = 0;
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawRoad();
      drawPlayer();
      drawUI();

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  })();
  </script>
</body>
</html>
